<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<title>Mini City 3D</title>

<style>
html,body{
  margin:0;
  padding:0;
  overflow:hidden;
  background:#0b0e14;
  font-family:Arial,Helvetica,sans-serif;
}
#ui{
  position:fixed;
  top:10px;
  left:10px;
  z-index:10;
  display:flex;
  flex-direction:column;
  gap:8px;
}
button{
  padding:10px 14px;
  border:none;
  border-radius:10px;
  background:#1f2433;
  color:#fff;
  font-size:14px;
  cursor:pointer;
}
button.active{background:#4c7cff}
#hint{
  position:fixed;
  bottom:10px;
  left:50%;
  transform:translateX(-50%);
  color:#aaa;
  font-size:12px;
}
</style>
</head>

<body>
<div id="ui">
  <button id="buildBtn" class="active">üèó –°—Ç—Ä–æ–∏—Ç—å</button>
  <button id="deleteBtn">‚ùå –£–¥–∞–ª–∏—Ç—å</button>
  <button id="dayBtn">üåó –î–µ–Ω—å / –ù–æ—á—å</button>
  <button id="resetBtn">üîÑ –ù–æ–≤—ã–π –≥–æ—Ä–æ–¥</button>
</div>
<div id="hint">–¢–∞–ø / –∫–ª–∏–∫ ‚Äî –¥–µ–π—Å—Ç–≤–∏–µ ‚Ä¢ –ó—É–º ‚Äî –∫–æ–ª–µ—Å–æ / pinch</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<script>
/* ---------------- BASIC SETUP ---------------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87a8ff);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(20,25,20);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enablePan = false;
controls.maxPolarAngle = Math.PI/2.2;

/* ---------------- LIGHTING ---------------- */
let isNight = false;

const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(30,50,20);
sun.castShadow = true;
scene.add(sun);

const ambient = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambient);

/* ---------------- GROUND & GRID ---------------- */
const gridSize = 20;
const cellSize = 2;

const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(gridSize*cellSize, gridSize*cellSize),
  new THREE.MeshStandardMaterial({color:0x3a8f5a})
);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

const grid = new THREE.GridHelper(gridSize*cellSize, gridSize, 0x444444, 0x444444);
scene.add(grid);

/* ---------------- DATA ---------------- */
const buildings = {};
const roads = [];
const citizens = [];
const cars = [];

/* ---------------- HELPERS ---------------- */
function rand(a,b){return a+Math.random()*(b-a)}

function key(x,z){return x+"_"+z}

/* ---------------- BUILDINGS ---------------- */
function createBuilding(x,z){
  const h = rand(1.5,6);
  const geo = new THREE.BoxGeometry(1.8,h,1.8);

  const mat = new THREE.MeshStandardMaterial({
    color:new THREE.Color().setHSL(Math.random(),0.5,0.6)
  });

  const m = new THREE.Mesh(geo,mat);
  m.position.set(x,h/2,z);
  m.castShadow = true;
  m.userData.type="building";
  scene.add(m);
  buildings[key(x,z)] = m;
}

/* ---------------- ROADS ---------------- */
function createRoad(x,z){
  const m = new THREE.Mesh(
    new THREE.BoxGeometry(2,0.1,2),
    new THREE.MeshStandardMaterial({color:0x2b2b2b})
  );
  m.position.set(x,0.05,z);
  m.receiveShadow = true;
  m.userData.type="road";
  scene.add(m);
  roads.push(m);
}

/* ---------------- PEOPLE ---------------- */
function spawnCitizen(){
  const m = new THREE.Mesh(
    new THREE.BoxGeometry(0.4,0.8,0.4),
    new THREE.MeshStandardMaterial({color:0xffcc88})
  );
  m.position.set(rand(-10,10),0.4,rand(-10,10));
  m.userData.dir = Math.random()*Math.PI*2;
  scene.add(m);
  citizens.push(m);
}

/* ---------------- CARS ---------------- */
function spawnCar(){
  const m = new THREE.Mesh(
    new THREE.BoxGeometry(0.8,0.4,1.4),
    new THREE.MeshStandardMaterial({color:0xff4444})
  );
  m.position.set(-20,0.25,rand(-10,10));
  m.userData.speed = rand(0.03,0.06);
  scene.add(m);
  cars.push(m);
}

/* ---------------- INTERACTION ---------------- */
let mode="build";

buildBtn.onclick=()=>{mode="build";buildBtn.classList.add("active");deleteBtn.classList.remove("active")}
deleteBtn.onclick=()=>{mode="delete";deleteBtn.classList.add("active");buildBtn.classList.remove("active")}

dayBtn.onclick=()=>{
  isNight=!isNight;
  if(isNight){
    sun.intensity=0.2;
    ambient.intensity=0.2;
    scene.background=new THREE.Color(0x05080f);
  }else{
    sun.intensity=1;
    ambient.intensity=0.4;
    scene.background=new THREE.Color(0x87a8ff);
  }
}

resetBtn.onclick=()=>location.reload();

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function onClick(e){
  mouse.x = (e.clientX/innerWidth)*2-1;
  mouse.y = -(e.clientY/innerHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);
  const hits = raycaster.intersectObjects(scene.children,true);
  if(!hits.length) return;

  const p = hits[0].point;
  const gx = Math.round(p.x/2)*2;
  const gz = Math.round(p.z/2)*2;
  const k = key(gx,gz);

  if(mode==="build"){
    if(!buildings[k]){
      createRoad(gx,gz);
      createBuilding(gx,gz);
    }
  }else{
    if(buildings[k]){
      scene.remove(buildings[k]);
      delete buildings[k];
    }
  }
}

window.addEventListener("pointerdown",onClick);

/* ---------------- SPAWN LIFE ---------------- */
for(let i=0;i<15;i++) spawnCitizen();
for(let i=0;i<6;i++) spawnCar();

/* ---------------- ANIMATION ---------------- */
function animate(){
  requestAnimationFrame(animate);
  controls.update();

  citizens.forEach(c=>{
    c.position.x+=Math.cos(c.userData.dir)*0.02;
    c.position.z+=Math.sin(c.userData.dir)*0.02;
    if(Math.random()<0.01) c.userData.dir=Math.random()*Math.PI*2;
  });

  cars.forEach(car=>{
    car.position.x+=car.userData.speed;
    if(car.position.x>20) car.position.x=-20;
  });

  renderer.render(scene,camera);
}
animate();

window.onresize=()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
}
</script>
</body>
</html>
