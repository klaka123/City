<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MEGA CITY 5120 - REAL 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            user-select: none;
        }

        body {
            overflow: hidden;
            background: #000;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        canvas {
            display: block;
        }

        .ui {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(10, 20, 30, 0.8);
            backdrop-filter: blur(10px);
            padding: 15px 35px;
            border-radius: 60px;
            color: #fff;
            font-size: 20px;
            z-index: 100;
            border: 1px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            pointer-events: none;
        }

        .ui div {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 22px;
            border-radius: 40px;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid rgba(255,255,255,0.1);
            pointer-events: auto;
        }

        .menu-left {
            position: fixed;
            top: 50%;
            left: 30px;
            transform: translateY(-50%);
            width: 380px;
            height: 80vh;
            background: rgba(10, 20, 30, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 40px;
            padding: 25px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 100;
            border: 1px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 20px 40px rgba(0,0,0,0.6);
            pointer-events: auto;
        }

        .menu-left h2 {
            color: #ffd700;
            text-align: center;
            font-size: 28px;
            text-shadow: 0 0 20px rgba(255,215,0,0.5);
            letter-spacing: 2px;
        }

        .categories {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }

        .categories button {
            flex: 1;
            min-width: 100px;
            padding: 12px;
            border-radius: 30px;
            border: none;
            cursor: pointer;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-weight: bold;
            transition: all 0.3s;
            border: 1px solid transparent;
        }

        .categories button:hover {
            background: rgba(255,215,0,0.2);
            border-color: #ffd700;
            transform: scale(1.03);
        }

        .list {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
        }

        .list::-webkit-scrollbar {
            width: 6px;
        }

        .list::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
        }

        .list::-webkit-scrollbar-thumb {
            background: #ffd700;
            border-radius: 10px;
        }

        .item {
            background: rgba(255,255,255,0.08);
            margin-bottom: 10px;
            padding: 15px;
            border-radius: 25px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid transparent;
        }

        .item:hover {
            background: rgba(255,215,0,0.15);
            transform: translateX(5px);
            border-color: rgba(255,215,0,0.5);
        }

        .item.selected {
            border-color: #ffd700;
            background: rgba(255,215,0,0.2);
            box-shadow: 0 0 20px rgba(255,215,0,0.3);
        }

        .menu-right {
            position: fixed;
            top: 50%;
            right: 30px;
            transform: translateY(-50%);
            background: rgba(10, 20, 30, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 40px;
            padding: 25px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 100;
            border: 1px solid rgba(255, 215, 0, 0.3);
            pointer-events: auto;
        }

        .menu-right button {
            padding: 15px 25px;
            font-size: 18px;
            border-radius: 40px;
            border: none;
            cursor: pointer;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-weight: bold;
            transition: all 0.3s;
            border: 1px solid transparent;
            min-width: 160px;
        }

        .menu-right button:hover {
            background: rgba(255,215,0,0.2);
            border-color: #ffd700;
            transform: scale(1.03);
        }

        .info {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 20, 30, 0.9);
            backdrop-filter: blur(15px);
            padding: 15px 40px;
            border-radius: 50px;
            color: #ffd700;
            font-size: 20px;
            font-weight: bold;
            z-index: 100;
            border: 1px solid rgba(255,215,0,0.3);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="info" id="info">üèóÔ∏è REAL 3D CITY BUILDER</div>
    
    <div class="ui">
        <div>üí∞ <span id="money">50,000,000</span></div>
        <div>üë• <span id="pop">0</span></div>
        <div>‚ö° <span id="inc">0</span></div>
        <div>üèóÔ∏è <span id="cnt">0/1600</span></div>
    </div>
    
    <div class="menu-left">
        <h2>üèóÔ∏è 3D –ö–ê–¢–ê–õ–û–ì</h2>
        <div class="categories" id="cats"></div>
        <div class="list" id="list"></div>
    </div>
    
    <div class="menu-right">
        <button onclick="collect()">üí∞ –°–ë–û–†</button>
        <button onclick="weather()">üå¶Ô∏è –ü–û–ì–û–î–ê</button>
        <button onclick="timeDay()">‚è∞ –í–†–ï–ú–Ø</button>
        <button onclick="cancel()">‚ùå –û–¢–ú–ï–ù–ê</button>
        <button onclick="resetGame()">üîÑ –ù–û–í–´–ô –ì–û–†–û–î</button>
    </div>

    <!-- Three.js –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        const tg = window.Telegram?.WebApp;
        tg?.expand();
        tg?.ready();

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ü–µ–Ω—ã Three.js
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a1a2a);
        scene.fog = new THREE.Fog(0x0a1a2a, 100, 300);

        // –ö–∞–º–µ—Ä–∞
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(50, 50, 100);
        camera.lookAt(0, 0, 0);

        // –†–µ–Ω–¥–µ—Ä–µ—Ä—ã
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // CSS2D —Ä–µ–Ω–¥–µ—Ä–µ—Ä –¥–ª—è —ç–º–æ–¥–∑–∏
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.left = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        container.appendChild(labelRenderer.domElement);

        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = true;
        controls.maxPolarAngle = Math.PI / 3;
        controls.minDistance = 30;
        controls.maxDistance = 200;
        controls.enableZoom = true;
        controls.rotateSpeed = 0.8;
        controls.panSpeed = 0.8;

        // –û—Å–≤–µ—â–µ–Ω–∏–µ
        // –û—Å–Ω–æ–≤–Ω–æ–π —Å–≤–µ—Ç
        const ambientLight = new THREE.AmbientLight(0x404060);
        scene.add(ambientLight);

        // –°–æ–ª–Ω—Ü–µ
        const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.2);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        sunLight.receiveShadow = true;
        sunLight.shadow.mapSize.width = 1024;
        sunLight.shadow.mapSize.height = 1024;
        const d = 150;
        sunLight.shadow.camera.left = -d;
        sunLight.shadow.camera.right = d;
        sunLight.shadow.camera.top = d;
        sunLight.shadow.camera.bottom = -d;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 200;
        scene.add(sunLight);

        // –ó–∞–ø–æ–ª–Ω—è—é—â–∏–π —Å–≤–µ—Ç
        const fillLight = new THREE.DirectionalLight(0x446688, 0.5);
        fillLight.position.set(-50, 50, -50);
        scene.add(fillLight);

        // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Å–Ω–∏–∑—É
        const bottomLight = new THREE.PointLight(0x335577, 0.3);
        bottomLight.position.set(0, -10, 0);
        scene.add(bottomLight);

        // –°–µ—Ç–∫–∞ –∑–µ–º–ª–∏
        const gridSize = 100;
        const gridDivisions = 40;
        
        // –û—Å–Ω–æ–≤–∞ –∑–µ–º–ª–∏
        const groundGeometry = new THREE.PlaneGeometry(gridSize, gridSize);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x2a5a2a, roughness: 0.8, metalness: 0.1 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        ground.receiveShadow = true;
        scene.add(ground);

        // –î–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω–∞—è —Å–µ—Ç–∫–∞
        const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x88aa88, 0x446644);
        gridHelper.position.y = 0.01;
        scene.add(gridHelper);

        // –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∑–¥–∞–Ω–∏–π
        const buildings = {};
        let buildingId = 0;

        // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è 3D –º–æ–¥–µ–ª–∏ –∑–¥–∞–Ω–∏—è
        function createBuilding3D(type, level, color, accent) {
            const group = new THREE.Group();
            
            const width = 2.5 + level * 0.3;
            const depth = 2.5 + level * 0.3;
            const height = 1.5 + level * 0.6;
            
            // –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ—Ä–ø—É—Å
            const bodyGeo = new THREE.BoxGeometry(width, height, depth);
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.4,
                metalness: 0.1,
                emissive: new THREE.Color(0x000000)
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.castShadow = true;
            body.receiveShadow = true;
            body.position.y = height / 2;
            group.add(body);
            
            // –ö—Ä—ã—à–∞
            const roofGeo = new THREE.ConeGeometry(width * 0.8, height * 0.4, 4);
            const roofMat = new THREE.MeshStandardMaterial({ 
                color: accent,
                roughness: 0.3,
                metalness: 0.3,
                emissive: new THREE.Color(0x221100)
            });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.castShadow = true;
            roof.receiveShadow = true;
            roof.position.y = height + height * 0.2;
            roof.rotation.y = Math.PI / 4;
            group.add(roof);
            
            // –û–∫–Ω–∞ (–º–∞–ª–µ–Ω—å–∫–∏–µ –∫—É–±–∏–∫–∏)
            const windowMat = new THREE.MeshStandardMaterial({ 
                color: 0xffdd88,
                emissive: new THREE.Color(0x442200),
                transparent: true,
                opacity: 0.9
            });
            
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 2; j++) {
                    const windowGeo = new THREE.BoxGeometry(0.3, 0.4, 0.1);
                    const windowMesh = new THREE.Mesh(windowGeo, windowMat);
                    windowMesh.castShadow = true;
                    windowMesh.receiveShadow = true;
                    
                    // –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–∫–Ω–∞ –ø–æ —Å—Ç–æ—Ä–æ–Ω–∞–º
                    if (i < 2) {
                        windowMesh.position.set(
                            (i === 0 ? -width/2 + 0.6 : width/2 - 0.6),
                            height * 0.5 + j * 0.5,
                            0
                        );
                    } else {
                        windowMesh.position.set(
                            0,
                            height * 0.5 + j * 0.5,
                            (i === 2 ? -depth/2 + 0.6 : depth/2 - 0.6)
                        );
                    }
                    group.add(windowMesh);
                }
            }
            
            // –î–≤–µ—Ä—å
            const doorGeo = new THREE.BoxGeometry(0.8, 1.0, 0.2);
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const door = new THREE.Mesh(doorGeo, doorMat);
            door.castShadow = true;
            door.receiveShadow = true;
            door.position.set(0, 0.5, depth/2 + 0.1);
            group.add(door);
            
            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–µ—Ç–∞–ª–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞
            if (type === 'res') {
                // –ë–∞–ª–∫–æ–Ω—ã
                const balconyGeo = new THREE.BoxGeometry(1.2, 0.2, 0.8);
                const balconyMat = new THREE.MeshStandardMaterial({ color: 0xCCCCCC });
                const balcony = new THREE.Mesh(balconyGeo, balconyMat);
                balcony.castShadow = true;
                balcony.receiveShadow = true;
                balcony.position.set(width/2 - 0.5, height * 0.8, 0);
                group.add(balcony);
            } else if (type === 'com') {
                // –í—ã–≤–µ—Å–∫–∞
                const signGeo = new THREE.BoxGeometry(1.5, 0.3, 0.2);
                const signMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: new THREE.Color(0x442200) });
                const sign = new THREE.Mesh(signGeo, signMat);
                sign.castShadow = true;
                sign.receiveShadow = true;
                sign.position.set(0, height + 0.5, depth/2);
                group.add(sign);
            } else if (type === 'ind') {
                // –¢—Ä—É–±–∞
                const pipeGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.5);
                const pipeMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
                const pipe = new THREE.Mesh(pipeGeo, pipeMat);
                pipe.castShadow = true;
                pipe.receiveShadow = true;
                pipe.position.set(width/2 - 0.5, height + 0.75, -depth/2 + 0.5);
                group.add(pipe);
            }
            
            return group;
        }

        // –°–∏—Å—Ç–µ–º–∞ —Å–µ—Ç–∫–∏ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è
        const GRID_SIZE = 40;
        const CELL_SIZE = 3;
        const grid = [];

        for (let x = 0; x < GRID_SIZE; x++) {
            grid[x] = [];
            for (let z = 0; z < GRID_SIZE; z++) {
                grid[x][z] = null;
            }
        }

        // –î–∞–Ω–Ω—ã–µ –∏–≥—Ä—ã
        let gameData = {
            money: 50000000,
            pop: 0,
            cnt: 0,
            weather: 0,
            time: 0.6
        };

        // –ö–∞—Ç–µ–≥–æ—Ä–∏–∏
        const cats = [
            { id: 'res', name: '–ñ–∏–ª—ã–µ', emoji: 'üèòÔ∏è', color: 0x4CAF50, accent: 0x81C784 },
            { id: 'com', name: '–¢–æ—Ä–≥–æ–≤—ã–µ', emoji: 'üè¨', color: 0xFF9800, accent: 0xFFB74D },
            { id: 'ind', name: '–ü—Ä–æ–º—ã—à–ª–µ–Ω–Ω—ã–µ', emoji: 'üè≠', color: 0xF44336, accent: 0xE57373 },
            { id: 'fun', name: '–†–∞–∑–≤–ª–µ—á–µ–Ω–∏—è', emoji: 'üé™', color: 0x9C27B0, accent: 0xBA68C8 },
            { id: 'gov', name: '–ì–æ—Å', emoji: 'üèõÔ∏è', color: 0x2196F3, accent: 0x64B5F6 }
        ];

        // –ö–∞—Ç–∞–ª–æ–≥ –∑–¥–∞–Ω–∏–π
        const catalog = [];
        cats.forEach((cat, ci) => {
            for (let i = 1; i <= 10; i++) {
                catalog.push({
                    id: `b_${cat.id}_${i}`,
                    cat: cat.id,
                    name: `${cat.name} —É—Ä–æ–≤–µ–Ω—å ${i}`,
                    level: i,
                    price: 100000 * i * (ci + 1),
                    inc: 5000 * i * (ci + 1),
                    pop: 50 * i * (ci + 1),
                    emoji: cat.emoji,
                    color: cat.color,
                    accent: cat.accent
                });
            }
        });

        let selectedBuilding = null;
        let hoveredCell = { x: -1, z: -1 };

        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Å–µ—Ç–∫–∞ –¥–ª—è –ø–æ–¥—Å–≤–µ—Ç–∫–∏
        const highlightMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffd700,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const highlightGeo = new THREE.BoxGeometry(CELL_SIZE, 0.1, CELL_SIZE);
        const highlightMesh = new THREE.Mesh(highlightGeo, highlightMaterial);
        highlightMesh.visible = false;
        scene.add(highlightMesh);

        // CSS2D –º–µ—Ç–∫–∏ –¥–ª—è —ç–º–æ–¥–∑–∏
        function createLabel(emoji, x, y, z) {
            const div = document.createElement('div');
            div.textContent = emoji;
            div.style.fontSize = '32px';
            div.style.fontWeight = 'bold';
            div.style.textShadow = '2px 2px 4px black';
            div.style.pointerEvents = 'none';
            
            const label = new CSS2DObject(div);
            label.position.set(x, y, z);
            return label;
        }

        // Raycaster –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ –º—ã—à–∏
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–æ–≤
        renderer.domElement.addEventListener('click', (event) => {
            if (!selectedBuilding) return;
            
            // –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –º—ã—à–∏
            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // –ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å –ø–ª–æ—Å–∫–æ—Å—Ç—å—é –∑–µ–º–ª–∏
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, target);
            
            // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Å–µ—Ç–∫–∏
            const gridX = Math.floor((target.x + GRID_SIZE * CELL_SIZE / 2) / CELL_SIZE);
            const gridZ = Math.floor((target.z + GRID_SIZE * CELL_SIZE / 2) / CELL_SIZE);
            
            if (gridX >= 0 && gridX < GRID_SIZE && gridZ >= 0 && gridZ < GRID_SIZE) {
                build(gridX, gridZ);
            }
        });

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–¥—Å–≤–µ—Ç–∫–∏
        renderer.domElement.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, target);
            
            const gridX = Math.floor((target.x + GRID_SIZE * CELL_SIZE / 2) / CELL_SIZE);
            const gridZ = Math.floor((target.z + GRID_SIZE * CELL_SIZE / 2) / CELL_SIZE);
            
            if (gridX >= 0 && gridX < GRID_SIZE && gridZ >= 0 && gridZ < GRID_SIZE) {
                hoveredCell.x = gridX;
                hoveredCell.z = gridZ;
                
                const worldX = (gridX - GRID_SIZE/2) * CELL_SIZE + CELL_SIZE/2;
                const worldZ = (gridZ - GRID_SIZE/2) * CELL_SIZE + CELL_SIZE/2;
                
                highlightMesh.position.set(worldX, 0.1, worldZ);
                highlightMesh.visible = true && selectedBuilding;
            } else {
                highlightMesh.visible = false;
            }
        });

        // –§—É–Ω–∫—Ü–∏—è —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
        function build(x, z) {
            const building = catalog.find(b => b.id === selectedBuilding);
            if (!building) return;
            
            if (gameData.money < building.price) {
                document.getElementById('info').innerText = '‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤!';
                return;
            }
            
            if (grid[x][z]) {
                document.getElementById('info').innerText = '‚ùå –ö–ª–µ—Ç–∫–∞ –∑–∞–Ω—è—Ç–∞!';
                return;
            }
            
            // –°–æ–∑–¥–∞–µ–º –∑–¥–∞–Ω–∏–µ
            const model = createBuilding3D(
                building.cat,
                building.level,
                building.color,
                building.accent
            );
            
            const worldX = (x - GRID_SIZE/2) * CELL_SIZE + CELL_SIZE/2;
            const worldZ = (z - GRID_SIZE/2) * CELL_SIZE + CELL_SIZE/2;
            model.position.set(worldX, 0, worldZ);
            
            scene.add(model);
            
            // –î–æ–±–∞–≤–ª—è–µ–º —ç–º–æ–¥–∑–∏
            const label = createLabel(building.emoji, worldX, 4 + building.level * 0.8, worldZ);
            scene.add(label);
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ —Å–µ—Ç–∫–µ
            grid[x][z] = {
                model,
                label,
                building
            };
            
            gameData.money -= building.price;
            gameData.pop += building.pop;
            gameData.cnt++;
            
            updateUI();
            document.getElementById('info').innerText = `‚úÖ –ü–æ—Å—Ç—Ä–æ–µ–Ω–æ: ${building.name}`;
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI
        function updateUI() {
            document.getElementById('money').innerText = gameData.money.toLocaleString();
            document.getElementById('pop').innerText = gameData.pop.toLocaleString();
            
            let totalInc = 0;
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let z = 0; z < GRID_SIZE; z++) {
                    if (grid[x][z]) {
                        totalInc += grid[x][z].building.inc;
                    }
                }
            }
            document.getElementById('inc').innerText = totalInc.toLocaleString();
            document.getElementById('cnt').innerText = `${gameData.cnt}/${GRID_SIZE * GRID_SIZE}`;
        }

        // –ò–≥—Ä–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
        window.collect = function() {
            let total = 0;
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let z = 0; z < GRID_SIZE; z++) {
                    if (grid[x][z]) {
                        total += grid[x][z].building.inc;
                    }
                }
            }
            gameData.money += total;
            updateUI();
            document.getElementById('info').innerText = `üí∞ –°–æ–±—Ä–∞–Ω–æ: ${total.toLocaleString()}`;
        };

        window.weather = function() {
            gameData.weather = (gameData.weather + 1) % 3;
            const weatherNames = ['‚òÄÔ∏è –Ø—Å–Ω–æ', 'üåßÔ∏è –î–æ–∂–¥—å', '‚ùÑÔ∏è –°–Ω–µ–≥'];
            
            // –ú–µ–Ω—è–µ–º –æ—Å–≤–µ—â–µ–Ω–∏–µ
            if (gameData.weather === 1) {
                sunLight.intensity = 0.6;
                ambientLight.intensity = 0.5;
            } else if (gameData.weather === 2) {
                sunLight.intensity = 0.8;
                ambientLight.intensity = 0.6;
            } else {
                sunLight.intensity = 1.2;
                ambientLight.intensity = 0.4;
            }
            
            document.getElementById('info').innerText = weatherNames[gameData.weather];
        };

        window.timeDay = function() {
            gameData.time = (gameData.time + 0.2) % 1;
            
            // –ú–µ–Ω—è–µ–º —Ü–≤–µ—Ç –æ—Å–≤–µ—â–µ–Ω–∏—è
            if (gameData.time < 0.3) {
                sunLight.color.setHex(0xffeedd);
                ambientLight.intensity = 0.2;
            } else if (gameData.time < 0.6) {
                sunLight.color.setHex(0xfff5e6);
                ambientLight.intensity = 0.4;
            } else {
                sunLight.color.setHex(0xffaa66);
                ambientLight.intensity = 0.3;
            }
        };

        window.cancel = function() {
            selectedBuilding = null;
            highlightMesh.visible = false;
            document.getElementById('info').innerText = 'üèóÔ∏è –í—ã–±–µ—Ä–∏—Ç–µ –∑–¥–∞–Ω–∏–µ';
            document.querySelectorAll('.item').forEach(i => i.classList.remove('selected'));
        };

        window.resetGame = function() {
            if (confirm('–ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –≥–æ—Ä–æ–¥?')) {
                location.reload();
            }
        };

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è UI
        const catsDiv = document.getElementById('cats');
        const listDiv = document.getElementById('list');
        
        cats.forEach(cat => {
            const btn = document.createElement('button');
            btn.innerHTML = `${cat.emoji} ${cat.name}`;
            btn.onclick = () => {
                listDiv.innerHTML = '';
                catalog.filter(b => b.cat === cat.id).forEach(building => {
                    const item = document.createElement('div');
                    item.className = 'item';
                    item.innerHTML = `
                        <div style="font-size: 24px;">${building.emoji}</div>
                        <div style="flex:1">
                            <div style="font-weight:bold">${building.name}</div>
                            <div style="font-size:14px; color:#aaa; display:flex; gap:10px; margin-top:5px;">
                                <span style="color:#ffd700">üí∞ ${building.price.toLocaleString()}</span>
                                <span style="color:#4CAF50">‚ö° ${building.inc}</span>
                                <span style="color:#2196F3">üë• ${building.pop}</span>
                            </div>
                        </div>
                    `;
                    item.onclick = () => {
                        document.querySelectorAll('.item').forEach(i => i.classList.remove('selected'));
                        item.classList.add('selected');
                        selectedBuilding = building.id;
                        document.getElementById('info').innerText = `üèóÔ∏è –í—ã–±—Ä–∞–Ω–æ: ${building.name}`;
                    };
                    listDiv.appendChild(item);
                });
            };
            catsDiv.appendChild(btn);
        });

        // –ê–Ω–∏–º–∞—Ü–∏—è
        function animate() {
            requestAnimationFrame(animate);
            
            controls.update();
            
            // –ê–Ω–∏–º–∞—Ü–∏—è –ø–æ–¥—Å–≤–µ—Ç–∫–∏
            if (highlightMesh.visible) {
                highlightMesh.material.opacity = 0.3 + Math.sin(Date.now() * 0.005) * 0.1;
            }
            
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }
        
        animate();

        // –ê–¥–∞–ø—Ç–∞—Ü–∏—è –∫ —Ä–µ—Å–∞–π–∑—É
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        updateUI();
    </script>
</body>
</html>
