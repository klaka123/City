<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MEGA CITY 5120 - ULTRA HD 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            user-select: none;
        }

        body {
            overflow: hidden;
            background: #000;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        canvas {
            display: block;
        }

        .ui {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(10, 20, 30, 0.85);
            backdrop-filter: blur(15px);
            padding: 15px 35px;
            border-radius: 60px;
            color: #fff;
            font-size: 20px;
            z-index: 100;
            border: 1px solid rgba(255, 215, 0, 0.4);
            box-shadow: 0 20px 40px rgba(0,0,0,0.6);
            pointer-events: none;
        }

        .ui div {
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 22px;
            border-radius: 40px;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid rgba(255,255,255,0.15);
            pointer-events: auto;
            transition: all 0.3s;
        }

        .ui div:hover {
            background: rgba(255,215,0,0.15);
            border-color: #ffd700;
            transform: translateY(-2px);
        }

        .menu-left {
            position: fixed;
            top: 50%;
            left: 30px;
            transform: translateY(-50%);
            width: 420px;
            height: 85vh;
            background: rgba(10, 20, 30, 0.92);
            backdrop-filter: blur(20px);
            border-radius: 50px;
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 100;
            border: 1px solid rgba(255, 215, 0, 0.4);
            box-shadow: 0 30px 60px rgba(0,0,0,0.8);
            pointer-events: auto;
            animation: slideInLeft 0.5s ease;
        }

        @keyframes slideInLeft {
            from { opacity: 0; transform: translateY(-50%) translateX(-50px); }
            to { opacity: 1; transform: translateY(-50%) translateX(0); }
        }

        .menu-left h2 {
            color: #ffd700;
            text-align: center;
            font-size: 32px;
            text-shadow: 0 0 30px rgba(255,215,0,0.5);
            letter-spacing: 3px;
            margin-bottom: 10px;
        }

        .categories {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .categories button {
            flex: 1;
            min-width: 110px;
            padding: 14px;
            border-radius: 40px;
            border: none;
            cursor: pointer;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 1px solid rgba(255,215,0,0.3);
        }

        .categories button:hover {
            background: linear-gradient(135deg, rgba(255,215,0,0.3) 0%, rgba(255,215,0,0.2) 100%);
            border-color: #ffd700;
            transform: scale(1.08) translateY(-2px);
            box-shadow: 0 10px 30px rgba(255,215,0,0.3);
        }

        .list {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
        }

        .list::-webkit-scrollbar {
            width: 8px;
        }

        .list::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
        }

        .list::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            border-radius: 10px;
        }

        .item {
            background: rgba(255,255,255,0.08);
            margin-bottom: 12px;
            padding: 18px;
            border-radius: 30px;
            color: #fff;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 2px solid transparent;
            display: flex;
            align-items: center;
            gap: 15px;
            backdrop-filter: blur(5px);
        }

        .item:hover {
            background: rgba(255,215,0,0.15);
            transform: translateX(8px) scale(1.02);
            border-color: rgba(255,215,0,0.6);
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
        }

        .item.selected {
            border-color: #ffd700;
            background: rgba(255,215,0,0.2);
            box-shadow: 0 0 40px rgba(255,215,0,0.4);
            transform: scale(1.03);
        }

        .menu-right {
            position: fixed;
            top: 50%;
            right: 30px;
            transform: translateY(-50%);
            background: rgba(10, 20, 30, 0.92);
            backdrop-filter: blur(20px);
            border-radius: 50px;
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 18px;
            z-index: 100;
            border: 1px solid rgba(255, 215, 0, 0.4);
            pointer-events: auto;
            animation: slideInRight 0.5s ease;
        }

        @keyframes slideInRight {
            from { opacity: 0; transform: translateY(-50%) translateX(50px); }
            to { opacity: 1; transform: translateY(-50%) translateX(0); }
        }

        .menu-right button {
            padding: 18px 30px;
            font-size: 18px;
            border-radius: 50px;
            border: none;
            cursor: pointer;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
            color: #fff;
            font-weight: bold;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 1px solid rgba(255,215,0,0.3);
            min-width: 180px;
        }

        .menu-right button:hover {
            background: linear-gradient(135deg, rgba(255,215,0,0.3) 0%, rgba(255,215,0,0.2) 100%);
            border-color: #ffd700;
            transform: scale(1.08) translateY(-3px);
            box-shadow: 0 15px 40px rgba(255,215,0,0.4);
        }

        .info {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 20, 30, 0.92);
            backdrop-filter: blur(20px);
            padding: 18px 50px;
            border-radius: 60px;
            color: #ffd700;
            font-size: 22px;
            font-weight: bold;
            z-index: 100;
            border: 1px solid rgba(255,215,0,0.4);
            box-shadow: 0 15px 40px rgba(0,0,0,0.6);
            letter-spacing: 2px;
            pointer-events: none;
            animation: fadeInDown 0.5s ease;
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateX(-50%) translateY(-30px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        .time-indicator {
            position: fixed;
            top: 30px;
            right: 30px;
            background: rgba(10, 20, 30, 0.92);
            backdrop-filter: blur(20px);
            padding: 12px 30px;
            border-radius: 50px;
            color: #fff;
            z-index: 100;
            border: 1px solid rgba(255,215,0,0.4);
            font-size: 18px;
            animation: fadeInRight 0.5s ease;
            pointer-events: none;
        }

        @keyframes fadeInRight {
            from { opacity: 0; transform: translateX(30px); }
            to { opacity: 1; transform: translateX(0); }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="info" id="info">üèóÔ∏è MEGA CITY 5120 - ULTRA HD 3D</div>
    <div class="time-indicator" id="timeIndicator">‚òÄÔ∏è –ü–û–õ–î–ï–ù–¨</div>
    
    <div class="ui">
        <div><span style="color:#ffd700">üí∞</span> <span id="money">100,000,000</span></div>
        <div><span style="color:#4CAF50">üë•</span> <span id="pop">0</span></div>
        <div><span style="color:#FF9800">‚ö°</span> <span id="inc">0</span></div>
        <div><span style="color:#2196F3">üèóÔ∏è</span> <span id="cnt">0/2500</span></div>
    </div>
    
    <div class="menu-left">
        <h2>üèóÔ∏è ULTRA HD –ö–ê–¢–ê–õ–û–ì</h2>
        <div class="categories" id="cats"></div>
        <div class="list" id="list"></div>
    </div>
    
    <div class="menu-right">
        <button onclick="collect()"><span style="color:#ffd700">üí∞</span> –°–ë–û–†</button>
        <button onclick="weather()"><span style="color:#87CEEB">üå¶Ô∏è</span> –ü–û–ì–û–î–ê</button>
        <button onclick="timeDay()"><span style="color:#ffd700">‚è∞</span> –í–†–ï–ú–Ø</button>
        <button onclick="cancel()"><span style="color:#ff6b6b">‚ùå</span> –û–¢–ú–ï–ù–ê</button>
        <button onclick="resetGame()"><span style="color:#4CAF50">üîÑ</span> –ù–û–í–´–ô –ì–û–†–û–î</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        const tg = window.Telegram?.WebApp;
        tg?.expand();
        tg?.ready();

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ü–µ–Ω—ã
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a1a2a);
        scene.fog = new THREE.Fog(0x0a1a2a, 150, 400);

        // –ö–∞–º–µ—Ä–∞
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(80, 60, 120);
        camera.lookAt(0, 0, 0);

        // –†–µ–Ω–¥–µ—Ä–µ—Ä—ã
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.shadowMap.bias = 0.0001;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.left = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        container.appendChild(labelRenderer.domElement);

        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = true;
        controls.maxPolarAngle = Math.PI / 2.5;
        controls.minDistance = 40;
        controls.maxDistance = 300;
        controls.enableZoom = true;
        controls.rotateSpeed = 0.6;
        controls.panSpeed = 0.8;
        controls.target.set(0, 10, 0);

        // –û—Å–≤–µ—â–µ–Ω–∏–µ
        const ambientLight = new THREE.AmbientLight(0x404060, 0.6);
        scene.add(ambientLight);

        // –°–æ–ª–Ω—Ü–µ (–æ—Å–Ω–æ–≤–Ω–æ–π —Å–≤–µ—Ç)
        const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.5);
        sunLight.position.set(80, 150, 80);
        sunLight.castShadow = true;
        sunLight.receiveShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        const d = 200;
        sunLight.shadow.camera.left = -d;
        sunLight.shadow.camera.right = d;
        sunLight.shadow.camera.top = d;
        sunLight.shadow.camera.bottom = -d;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 300;
        sunLight.shadow.bias = -0.0005;
        scene.add(sunLight);

        // –ó–∞–ø–æ–ª–Ω—è—é—â–∏–π —Å–≤–µ—Ç
        const fillLight = new THREE.DirectionalLight(0x88aadd, 0.5);
        fillLight.position.set(-50, 50, -50);
        scene.add(fillLight);

        // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Å–Ω–∏–∑—É
        const bottomLight = new THREE.PointLight(0x446688, 0.4);
        bottomLight.position.set(0, -10, 0);
        scene.add(bottomLight);

        // –¢–æ—á–µ—á–Ω—ã–µ –æ–≥–Ω–∏ –¥–ª—è –≥–æ—Ä–æ–¥–∞
        const cityLights = new THREE.Group();
        for (let i = 0; i < 20; i++) {
            const light = new THREE.PointLight(0xffaa33, 0.5, 30);
            light.position.set(Math.random() * 100 - 50, 5, Math.random() * 100 - 50);
            cityLights.add(light);
        }
        scene.add(cityLights);

        // –ó–µ–º–ª—è —Å —Ç–µ–∫—Å—Ç—É—Ä–æ–π
        const groundSize = 200;
        const groundGeo = new THREE.CircleGeometry(groundSize, 64);
        const groundMat = new THREE.MeshStandardMaterial({ 
            color: 0x2a5a2a,
            roughness: 0.8,
            metalness: 0.1,
            emissive: new THREE.Color(0x112211)
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        ground.receiveShadow = true;
        scene.add(ground);

        // –î–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å–µ—Ç–∫–∞
        const gridHelper = new THREE.GridHelper(groundSize, 50, 0x88aa88, 0x446644);
        gridHelper.position.y = 0.01;
        scene.add(gridHelper);

        // –î–æ—Ä–æ–≥–∏
        const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 });
        for (let i = -5; i <= 5; i++) {
            const roadH = new THREE.Mesh(new THREE.BoxGeometry(200, 0.1, 4), roadMat);
            roadH.position.set(0, 0.05, i * 20);
            roadH.receiveShadow = true;
            scene.add(roadH);
            
            const roadV = new THREE.Mesh(new THREE.BoxGeometry(4, 0.1, 200), roadMat);
            roadV.position.set(i * 20, 0.05, 0);
            roadV.receiveShadow = true;
            scene.add(roadV);
        }

        // –°–∏—Å—Ç–µ–º–∞ —Å–µ—Ç–∫–∏ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è
        const GRID_SIZE = 50;
        const CELL_SIZE = 4;
        const grid = [];

        for (let x = 0; x < GRID_SIZE; x++) {
            grid[x] = [];
            for (let z = 0; z < GRID_SIZE; z++) {
                grid[x][z] = null;
            }
        }

        // –î–∞–Ω–Ω—ã–µ –∏–≥—Ä—ã
        let gameData = {
            money: 100000000,
            pop: 0,
            cnt: 0,
            weather: 0,
            time: 0.6
        };

        // –ö–∞—Ç–µ–≥–æ—Ä–∏–∏ —Å —Ü–≤–µ—Ç–∞–º–∏
        const cats = [
            { id: 'res', name: '–ñ–∏–ª—ã–µ', emoji: 'üèòÔ∏è', color: 0x4CAF50, accent: 0x81C784, dark: 0x2E7D32 },
            { id: 'com', name: '–¢–æ—Ä–≥–æ–≤—ã–µ', emoji: 'üè¨', color: 0xFF9800, accent: 0xFFB74D, dark: 0xF57C00 },
            { id: 'ind', name: '–ü—Ä–æ–º—ã—à–ª–µ–Ω–Ω—ã–µ', emoji: 'üè≠', color: 0xF44336, accent: 0xE57373, dark: 0xC62828 },
            { id: 'edu', name: '–û–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ', emoji: 'üè´', color: 0x2196F3, accent: 0x64B5F6, dark: 0x1565C0 },
            { id: 'med', name: '–ú–µ–¥–∏—Ü–∏–Ω–∞', emoji: 'üè•', color: 0xE91E63, accent: 0xF06292, dark: 0xC2185B },
            { id: 'gov', name: '–ì–æ—Å. —É—á—Ä–µ–∂–¥–µ–Ω–∏—è', emoji: 'üèõÔ∏è', color: 0x9C27B0, accent: 0xBA68C8, dark: 0x6A1B9A },
            { id: 'skyscraper', name: '–ù–µ–±–æ—Å–∫—Ä–µ–±—ã', emoji: 'üèôÔ∏è', color: 0x607D8B, accent: 0x90A4AE, dark: 0x455A64 }
        ];

        // –°–õ–û–ñ–ù–´–ï –î–ï–¢–ê–õ–ò–ó–ò–†–û–í–ê–ù–ù–´–ï 3D –ú–û–î–ï–õ–ò
        function createResidential(level, color, accent, dark) {
            const group = new THREE.Group();
            const height = 2 + level * 0.8;
            const width = 3;
            const depth = 3;
            
            // –û—Å–Ω–æ–≤–Ω–æ–µ –∑–¥–∞–Ω–∏–µ —Å–æ —Å–ª–æ–∂–Ω–æ–π –≥–µ–æ–º–µ—Ç—Ä–∏–µ–π
            const bodyGeo = new THREE.BoxGeometry(width, height, depth);
            const bodyMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4, metalness: 0.1 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.castShadow = true;
            body.receiveShadow = true;
            body.position.y = height/2;
            group.add(body);
            
            // –î–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ–∫–Ω–∞
            const windowMat = new THREE.MeshStandardMaterial({ color: 0xffdd88, emissive: new THREE.Color(0x332200) });
            for (let floor = 0; floor < level + 1; floor++) {
                for (let i = -1; i <= 1; i++) {
                    // –û–∫–Ω–∞ —Å–ø–µ—Ä–µ–¥–∏
                    const windowGeo = new THREE.BoxGeometry(0.5, 0.8, 0.2);
                    const window1 = new THREE.Mesh(windowGeo, windowMat);
                    window1.position.set(i * 1.0, 0.8 + floor * 1.2, depth/2 + 0.1);
                    window1.castShadow = true;
                    group.add(window1);
                    
                    // –†–∞–º—ã –æ–∫–æ–Ω
                    const frameMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                    const frameGeo = new THREE.BoxGeometry(0.55, 0.85, 0.05);
                    const frame = new THREE.Mesh(frameGeo, frameMat);
                    frame.position.set(i * 1.0, 0.8 + floor * 1.2, depth/2 + 0.15);
                    frame.castShadow = true;
                    group.add(frame);
                }
            }
            
            // –ë–∞–ª–∫–æ–Ω—ã
            const balconyMat = new THREE.MeshStandardMaterial({ color: 0xCCCCCC });
            for (let floor = 1; floor < level; floor++) {
                const balconyGeo = new THREE.BoxGeometry(2.2, 0.2, 0.8);
                const balcony = new THREE.Mesh(balconyGeo, balconyMat);
                balcony.position.set(0, 0.5 + floor * 1.2, depth/2 - 0.3);
                balcony.castShadow = true;
                balcony.receiveShadow = true;
                group.add(balcony);
                
                // –ü–µ—Ä–∏–ª–∞
                const railGeo = new THREE.BoxGeometry(2.3, 0.1, 0.1);
                const rail = new THREE.Mesh(railGeo, balconyMat);
                rail.position.set(0, 0.8 + floor * 1.2, depth/2 - 0.1);
                rail.castShadow = true;
                group.add(rail);
            }
            
            // –ö—Ä—ã—à–∞ —Å–æ —Å–ª–æ–∂–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π
            const roofGeo = new THREE.ConeGeometry(1.8, 1.0, 8);
            const roofMat = new THREE.MeshStandardMaterial({ color: dark, roughness: 0.6 });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = height + 0.5;
            roof.castShadow = true;
            group.add(roof);
            
            // –ê–Ω—Ç–µ–Ω–Ω–∞
            const antennaGeo = new THREE.CylinderGeometry(0.1, 0.1, 1.0);
            const antennaMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
            const antenna = new THREE.Mesh(antennaGeo, antennaMat);
            antenna.position.set(0, height + 1.0, 0);
            antenna.castShadow = true;
            group.add(antenna);
            
            return group;
        }

        function createSkyscraper(level, color, accent, dark) {
            const group = new THREE.Group();
            const height = 8 + level * 1.5;
            const width = 2.5;
            const depth = 2.5;
            
            // –û—Å–Ω–æ–≤–Ω–∞—è –±–∞—à–Ω—è
            const towerGeo = new THREE.BoxGeometry(width, height, depth);
            const towerMat = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.3,
                metalness: 0.4,
                emissive: new THREE.Color(0x112233)
            });
            const tower = new THREE.Mesh(towerGeo, towerMat);
            tower.castShadow = true;
            tower.receiveShadow = true;
            tower.position.y = height/2;
            group.add(tower);
            
            // –°—Ç–µ–∫–ª—è–Ω–Ω—ã–µ –ø–∞–Ω–µ–ª–∏
            const glassMat = new THREE.MeshStandardMaterial({ 
                color: 0xaaccff,
                transparent: true,
                opacity: 0.6,
                emissive: new THREE.Color(0x112244)
            });
            
            for (let i = 0; i < 4; i++) {
                const glassGeo = new THREE.BoxGeometry(width - 0.3, height - 0.5, 0.2);
                const glass = new THREE.Mesh(glassGeo, glassMat);
                if (i === 0) glass.position.set(0, height/2, depth/2 + 0.1);
                if (i === 1) glass.position.set(0, height/2, -depth/2 - 0.1);
                if (i === 2) glass.position.set(width/2 + 0.1, height/2, 0);
                if (i === 3) glass.position.set(-width/2 - 0.1, height/2, 0);
                glass.castShadow = true;
                group.add(glass);
            }
            
            // –î–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω—ã–µ –ø–æ–ª–æ—Å—ã
            const stripMat = new THREE.MeshStandardMaterial({ color: accent });
            for (let i = 0; i < 5; i++) {
                const stripGeo = new THREE.BoxGeometry(width + 0.4, 0.2, depth + 0.4);
                const strip = new THREE.Mesh(stripGeo, stripMat);
                strip.position.set(0, i * (height/5), 0);
                strip.castShadow = true;
                group.add(strip);
            }
            
            // –®–ø–∏–ª—å
            const spireGeo = new THREE.ConeGeometry(0.8, 2.0, 8);
            const spireMat = new THREE.MeshStandardMaterial({ color: 0xffd700 });
            const spire = new THREE.Mesh(spireGeo, spireMat);
            spire.position.y = height + 1.0;
            spire.castShadow = true;
            group.add(spire);
            
            return group;
        }

        function createSchool(level, color, accent, dark) {
            const group = new THREE.Group();
            const height = 3 + level * 0.5;
            const width = 5;
            const depth = 4;
            
            // –û—Å–Ω–æ–≤–Ω–æ–µ –∑–¥–∞–Ω–∏–µ
            const mainGeo = new THREE.BoxGeometry(width, height, depth);
            const mainMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5 });
            const main = new THREE.Mesh(mainGeo, mainMat);
            main.castShadow = true;
            main.receiveShadow = true;
            main.position.y = height/2;
            group.add(main);
            
            // –ö—Ä—ã–ª—å—Ü–æ —Å –∫–æ–ª–æ–Ω–Ω–∞–º–∏
            const columnMat = new THREE.MeshStandardMaterial({ color: 0xCCCCCC });
            for (let i = -1; i <= 1; i++) {
                const columnGeo = new THREE.CylinderGeometry(0.3, 0.3, 2.0);
                const column = new THREE.Mesh(columnGeo, columnMat);
                column.position.set(i * 1.5, 1.0, depth/2 + 1.0);
                column.castShadow = true;
                column.receiveShadow = true;
                group.add(column);
            }
            
            // –ö—Ä—ã—à–∞ —Å –∫—É–ø–æ–ª–æ–º
            const domeGeo = new THREE.SphereGeometry(1.2, 16, 8);
            const domeMat = new THREE.MeshStandardMaterial({ color: accent });
            const dome = new THREE.Mesh(domeGeo, domeMat);
            dome.position.set(0, height + 0.5, -1);
            dome.scale.set(1, 0.5, 1);
            dome.castShadow = true;
            group.add(dome);
            
            // –§–ª–∞–≥
            const flagPoleGeo = new THREE.CylinderGeometry(0.1, 0.1, 2.0);
            const flagPoleMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
            const flagPole = new THREE.Mesh(flagPoleGeo, flagPoleMat);
            flagPole.position.set(width/2 - 0.5, height + 1.0, depth/2 - 0.5);
            flagPole.castShadow = true;
            group.add(flagPole);
            
            return group;
        }

        function createHospital(level, color, accent, dark) {
            const group = new THREE.Group();
            const height = 4;
            const width = 6;
            const depth = 5;
            
            // –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ—Ä–ø—É—Å
            const mainGeo = new THREE.BoxGeometry(width, height, depth);
            const mainMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
            const main = new THREE.Mesh(mainGeo, mainMat);
            main.castShadow = true;
            main.receiveShadow = true;
            main.position.y = height/2;
            group.add(main);
            
            // –ë–∞—à–Ω—è —Å –∫—Ä–µ—Å—Ç–æ–º
            const towerGeo = new THREE.BoxGeometry(1.5, 2.5, 1.5);
            const towerMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const tower = new THREE.Mesh(towerGeo, towerMat);
            tower.position.set(width/2 - 1, height + 1.25, -depth/2 + 1);
            tower.castShadow = true;
            group.add(tower);
            
            // –ö—Ä–∞—Å–Ω—ã–π –∫—Ä–µ—Å—Ç
            const crossMat = new THREE.MeshStandardMaterial({ color: 0xFF0000 });
            const crossHGeo = new THREE.BoxGeometry(1.2, 0.3, 0.3);
            const crossH = new THREE.Mesh(crossHGeo, crossMat);
            crossH.position.set(width/2 - 1, height + 2.0, -depth/2 + 1);
            crossH.castShadow = true;
            group.add(crossH);
            
            const crossVGeo = new THREE.BoxGeometry(0.3, 1.2, 0.3);
            const crossV = new THREE.Mesh(crossVGeo, crossMat);
            crossV.position.set(width/2 - 1, height + 2.0, -depth/2 + 1);
            crossV.castShadow = true;
            group.add(crossV);
            
            // –í—Ö–æ–¥
            const doorGeo = new THREE.BoxGeometry(1.5, 2.0, 0.5);
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const door = new THREE.Mesh(doorGeo, doorMat);
            door.position.set(0, 1.0, depth/2 + 0.3);
            door.castShadow = true;
            group.add(door);
            
            return group;
        }

        function createIndustrial(level, color, accent, dark) {
            const group = new THREE.Group();
            const height = 3 + level * 0.6;
            const width = 4;
            const depth = 4;
            
            // –ó–∞–≤–æ–¥—Å–∫–æ–π –∫–æ—Ä–ø—É—Å
            const mainGeo = new THREE.BoxGeometry(width, height, depth);
            const mainMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.7 });
            const main = new THREE.Mesh(mainGeo, mainMat);
            main.castShadow = true;
            main.receiveShadow = true;
            main.position.y = height/2;
            group.add(main);
            
            // –¢—Ä—É–±—ã
            const pipeMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
            for (let i = 0; i < 3; i++) {
                const pipeGeo = new THREE.CylinderGeometry(0.4, 0.5, 2.0 + i * 0.5);
                const pipe = new THREE.Mesh(pipeGeo, pipeMat);
                pipe.position.set(-1 + i * 1.5, height + 1.0 + i * 0.5, -1);
                pipe.castShadow = true;
                group.add(pipe);
            }
            
            // –†–µ–∑–µ—Ä–≤—É–∞—Ä—ã
            const tankMat = new THREE.MeshStandardMaterial({ color: 0xCCCCCC });
            for (let i = 0; i < 2; i++) {
                const tankGeo = new THREE.CylinderGeometry(1.0, 1.0, 2.0);
                const tank = new THREE.Mesh(tankGeo, tankMat);
                tank.position.set(1.5 + i * 2.0, 1.0, -1.5);
                tank.castShadow = true;
                group.add(tank);
            }
            
            // –î—ã–º
            const smokeMat = new THREE.MeshStandardMaterial({ color: 0xAAAAAA, transparent: true, opacity: 0.3 });
            const smokeGeo = new THREE.SphereGeometry(0.6, 8);
            const smoke = new THREE.Mesh(smokeGeo, smokeMat);
            smoke.position.set(-1, height + 2.5, -1);
            group.add(smoke);
            
            return group;
        }

        function createGovernment(level, color, accent, dark) {
            const group = new THREE.Group();
            const height = 4;
            const width = 6;
            const depth = 5;
            
            // –û—Å–Ω–æ–≤–Ω–æ–µ –∑–¥–∞–Ω–∏–µ
            const mainGeo = new THREE.BoxGeometry(width, height, depth);
            const mainMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3 });
            const main = new THREE.Mesh(mainGeo, mainMat);
            main.castShadow = true;
            main.receiveShadow = true;
            main.position.y = height/2;
            group.add(main);
            
            // –ö–æ–ª–æ–Ω–Ω—ã
            const columnMat = new THREE.MeshStandardMaterial({ color: 0xEEEEEE });
            for (let i = -2; i <= 2; i++) {
                const columnGeo = new THREE.CylinderGeometry(0.4, 0.5, 3.0);
                const column = new THREE.Mesh(columnGeo, columnMat);
                column.position.set(i * 1.2, 1.5, depth/2 + 0.8);
                column.castShadow = true;
                group.add(column);
            }
            
            // –§—Ä–æ–Ω—Ç–æ–Ω
            const pedimentGeo = new THREE.CylinderGeometry(3.0, 3.0, 1.0, 3);
            const pedimentMat = new THREE.MeshStandardMaterial({ color: accent });
            const pediment = new THREE.Mesh(pedimentGeo, pedimentMat);
            pediment.position.set(0, height + 0.5, depth/2);
            pediment.rotation.y = Math.PI;
            pediment.castShadow = true;
            group.add(pediment);
            
            // –§–ª–∞–≥
            const flagPoleGeo = new THREE.CylinderGeometry(0.1, 0.1, 3.0);
            const flagPoleMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
            const flagPole = new THREE.Mesh(flagPoleGeo, flagPoleMat);
            flagPole.position.set(-2, height + 2.0, -2);
            flagPole.castShadow = true;
            group.add(flagPole);
            
            return group;
        }

        // –ö–∞—Ç–∞–ª–æ–≥ –∑–¥–∞–Ω–∏–π
        const catalog = [];
        cats.forEach((cat, ci) => {
            const maxLevel = cat.id === 'skyscraper' ? 20 : 10;
            const size = cat.id === 'skyscraper' ? 1 : (cat.id === 'edu' || cat.id === 'med' || cat.id === 'gov' ? 2 : 1);
            
            for (let i = 1; i <= maxLevel; i++) {
                catalog.push({
                    id: `b_${cat.id}_${i}`,
                    cat: cat.id,
                    name: `${cat.name} —É—Ä. ${i}`,
                    level: i,
                    size: size,
                    price: 200000 * i * (ci + 1),
                    inc: 15000 * i * (ci + 1),
                    pop: 100 * i * (ci + 1),
                    emoji: cat.emoji,
                    color: cat.color,
                    accent: cat.accent,
                    dark: cat.dark,
                    createModel: () => {
                        switch(cat.id) {
                            case 'res': return createResidential(i, cat.color, cat.accent, cat.dark);
                            case 'skyscraper': return createSkyscraper(i, cat.color, cat.accent, cat.dark);
                            case 'edu': return createSchool(i, cat.color, cat.accent, cat.dark);
                            case 'med': return createHospital(i, cat.color, cat.accent, cat.dark);
                            case 'ind': return createIndustrial(i, cat.color, cat.accent, cat.dark);
                            case 'gov': return createGovernment(i, cat.color, cat.accent, cat.dark);
                            default: return createResidential(i, cat.color, cat.accent, cat.dark);
                        }
                    }
                });
            }
        });

        let selectedBuilding = null;
        let hoveredCell = { x: -1, z: -1 };

        // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è
        const highlightMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xffd700,
            transparent: true,
            opacity: 0.3,
            emissive: new THREE.Color(0x442200)
        });
        const highlightGeo = new THREE.BoxGeometry(CELL_SIZE, 0.1, CELL_SIZE);
        const highlightMesh = new THREE.Mesh(highlightGeo, highlightMaterial);
        highlightMesh.visible = false;
        scene.add(highlightMesh);

        // CSS2D –º–µ—Ç–∫–∏ –¥–ª—è —ç–º–æ–¥–∑–∏
        function createLabel(emoji, x, y, z) {
            const div = document.createElement('div');
            div.textContent = emoji;
            div.style.fontSize = '36px';
            div.style.fontWeight = 'bold';
            div.style.textShadow = '2px 2px 4px black, 0 0 20px #ffd700';
            div.style.pointerEvents = 'none';
            div.style.transform = 'translate(-50%, -50%)';
            
            const label = new CSS2DObject(div);
            label.position.set(x, y, z);
            return label;
        }

        // Raycaster
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        renderer.domElement.addEventListener('click', (event) => {
            if (!selectedBuilding) return;
            
            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, target);
            
            const building = catalog.find(b => b.id === selectedBuilding);
            if (!building) return;
            
            const size = building.size || 1;
            const gridX = Math.floor((target.x + GRID_SIZE * CELL_SIZE / 2) / CELL_SIZE);
            const gridZ = Math.floor((target.z + GRID_SIZE * CELL_SIZE / 2) / CELL_SIZE);
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥—Ä–∞–Ω–∏—Ü –¥–ª—è –º–Ω–æ–≥–æ–∫–ª–µ—Ç–æ—á–Ω—ã—Ö –∑–¥–∞–Ω–∏–π
            let canBuild = true;
            for (let dx = 0; dx < size; dx++) {
                for (let dz = 0; dz < size; dz++) {
                    const x = gridX + dx;
                    const z = gridZ + dz;
                    if (x >= GRID_SIZE || z >= GRID_SIZE || x < 0 || z < 0 || grid[x][z]) {
                        canBuild = false;
                    }
                }
            }
            
            if (canBuild) {
                build(gridX, gridZ, building);
            }
        });

        renderer.domElement.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, target);
            
            const gridX = Math.floor((target.x + GRID_SIZE * CELL_SIZE / 2) / CELL_SIZE);
            const gridZ = Math.floor((target.z + GRID_SIZE * CELL_SIZE / 2) / CELL_SIZE);
            
            if (gridX >= 0 && gridX < GRID_SIZE && gridZ >= 0 && gridZ < GRID_SIZE) {
                hoveredCell.x = gridX;
                hoveredCell.z = gridZ;
                
                const worldX = (gridX - GRID_SIZE/2) * CELL_SIZE + CELL_SIZE/2;
                const worldZ = (gridZ - GRID_SIZE/2) * CELL_SIZE + CELL_SIZE/2;
                
                highlightMesh.position.set(worldX, 0.1, worldZ);
                highlightMesh.visible = true && selectedBuilding;
                
                // –ò–∑–º–µ–Ω—è–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ–¥—Å–≤–µ—Ç–∫–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∑–¥–∞–Ω–∏—è
                if (selectedBuilding) {
                    const building = catalog.find(b => b.id === selectedBuilding);
                    if (building) {
                        const size = building.size || 1;
                        highlightMesh.scale.set(size, 1, size);
                    }
                }
            } else {
                highlightMesh.visible = false;
            }
        });

        function build(x, z, building) {
            if (gameData.money < building.price) {
                document.getElementById('info').innerText = '‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤!';
                return;
            }
            
            const size = building.size || 1;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –∫–ª–µ—Ç–æ–∫
            for (let dx = 0; dx < size; dx++) {
                for (let dz = 0; dz < size; dz++) {
                    if (grid[x + dx][z + dz]) {
                        document.getElementById('info').innerText = '‚ùå –ö–ª–µ—Ç–∫–∞ –∑–∞–Ω—è—Ç–∞!';
                        return;
                    }
                }
            }
            
            // –°–æ–∑–¥–∞–µ–º –∑–¥–∞–Ω–∏–µ
            const model = building.createModel();
            
            const centerX = (x + (size-1)/2 - GRID_SIZE/2) * CELL_SIZE;
            const centerZ = (z + (size-1)/2 - GRID_SIZE/2) * CELL_SIZE;
            
            model.position.set(centerX, 0, centerZ);
            model.scale.set(1.2, 1.2, 1.2);
            scene.add(model);
            
            // –î–æ–±–∞–≤–ª—è–µ–º —ç–º–æ–¥–∑–∏
            const label = createLabel(building.emoji, centerX, 5 + building.level * 0.5, centerZ);
            scene.add(label);
            
            // –ó–∞–ø–æ–ª–Ω—è–µ–º —Å–µ—Ç–∫—É
            for (let dx = 0; dx < size; dx++) {
                for (let dz = 0; dz < size; dz++) {
                    grid[x + dx][z + dz] = {
                        model,
                        label,
                        building,
                        part: { dx, dz }
                    };
                }
            }
            
            gameData.money -= building.price;
            gameData.pop += building.pop;
            gameData.cnt += size * size;
            
            updateUI();
            document.getElementById('info').innerText = `‚úÖ –ü–æ—Å—Ç—Ä–æ–µ–Ω–æ: ${building.name}`;
        }

        function updateUI() {
            document.getElementById('money').innerText = gameData.money.toLocaleString();
            document.getElementById('pop').innerText = gameData.pop.toLocaleString();
            
            let totalInc = 0;
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let z = 0; z < GRID_SIZE; z++) {
                    if (grid[x][z] && grid[x][z].building) {
                        totalInc += grid[x][z].building.inc;
                    }
                }
            }
            document.getElementById('inc').innerText = totalInc.toLocaleString();
            document.getElementById('cnt').innerText = `${gameData.cnt}/${GRID_SIZE * GRID_SIZE}`;
        }

        // –ò–≥—Ä–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
        window.collect = function() {
            let total = 0;
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let z = 0; z < GRID_SIZE; z++) {
                    if (grid[x][z] && grid[x][z].building) {
                        total += grid[x][z].building.inc;
                    }
                }
            }
            gameData.money += total;
            updateUI();
            document.getElementById('info').innerText = `üí∞ –°–æ–±—Ä–∞–Ω–æ: ${total.toLocaleString()}`;
        };

        window.weather = function() {
            gameData.weather = (gameData.weather + 1) % 3;
            const weatherNames = ['‚òÄÔ∏è –Ø—Å–Ω–æ', 'üåßÔ∏è –î–æ–∂–¥—å', '‚ùÑÔ∏è –°–Ω–µ–≥'];
            
            if (gameData.weather === 1) {
                sunLight.intensity = 0.8;
                ambientLight.intensity = 0.5;
            } else if (gameData.weather === 2) {
                sunLight.intensity = 1.0;
                ambientLight.intensity = 0.6;
            } else {
                sunLight.intensity = 1.5;
                ambientLight.intensity = 0.6;
            }
            
            document.getElementById('info').innerText = weatherNames[gameData.weather];
        };

        window.timeDay = function() {
            gameData.time = (gameData.time + 0.2) % 1;
            
            const timeNames = ['üåô –ù–æ—á—å', 'üåÖ –£—Ç—Ä–æ', '‚òÄÔ∏è –î–µ–Ω—å', 'üåÜ –í–µ—á–µ—Ä'];
            const index = Math.floor(gameData.time * 4);
            document.getElementById('timeIndicator').innerHTML = timeNames[index];
            
            // –ú–µ–Ω—è–µ–º –æ—Å–≤–µ—â–µ–Ω–∏–µ
            if (gameData.time < 0.25) {
                sunLight.color.setHex(0x446688);
                sunLight.intensity = 0.3;
            } else if (gameData.time < 0.5) {
                sunLight.color.setHex(0xffaa66);
                sunLight.intensity = 0.8;
            } else if (gameData.time < 0.75) {
                sunLight.color.setHex(0xfff5e6);
                sunLight.intensity = 1.5;
            } else {
                sunLight.color.setHex(0xff8844);
                sunLight.intensity = 0.6;
            }
        };

        window.cancel = function() {
            selectedBuilding = null;
            highlightMesh.visible = false;
            document.getElementById('info').innerText = 'üèóÔ∏è –í—ã–±–µ—Ä–∏—Ç–µ –∑–¥–∞–Ω–∏–µ';
            document.querySelectorAll('.item').forEach(i => i.classList.remove('selected'));
        };

        window.resetGame = function() {
            if (confirm('üí∞ –ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –≥–æ—Ä–æ–¥?')) {
                location.reload();
            }
        };

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è UI
        const catsDiv = document.getElementById('cats');
        const listDiv = document.getElementById('list');
        
        cats.forEach(cat => {
            const btn = document.createElement('button');
            btn.innerHTML = `${cat.emoji} ${cat.name}`;
            btn.onclick = () => {
                listDiv.innerHTML = '';
                catalog.filter(b => b.cat === cat.id).forEach(building => {
                    const item = document.createElement('div');
                    item.className = 'item';
                    item.innerHTML = `
                        <div style="font-size: 32px; min-width: 50px;">${building.emoji}</div>
                        <div style="flex:1">
                            <div style="font-weight:bold; font-size: 18px; color: #ffd700">${building.name}</div>
                            <div style="display: flex; gap: 15px; margin-top: 8px; font-size: 14px;">
                                <span style="color: #ffd700">üí∞ ${building.price.toLocaleString()}</span>
                                <span style="color: #4CAF50">‚ö° ${building.inc}</span>
                                <span style="color: #2196F3">üë• ${building.pop}</span>
                            </div>
                            <div style="font-size: 12px; color: #aaa; margin-top: 5px;">
                                –†–∞–∑–º–µ—Ä: ${building.size || 1}x${building.size || 1} | –£—Ä–æ–≤–µ–Ω—å ${building.level}
                            </div>
                        </div>
                    `;
                    item.onclick = () => {
                        document.querySelectorAll('.item').forEach(i => i.classList.remove('selected'));
                        item.classList.add('selected');
                        selectedBuilding = building.id;
                        document.getElementById('info').innerText = `üèóÔ∏è –í—ã–±—Ä–∞–Ω–æ: ${building.name}`;
                    };
                    listDiv.appendChild(item);
                });
            };
            catsDiv.appendChild(btn);
        });

        // –ê–Ω–∏–º–∞—Ü–∏—è
        function animate() {
            requestAnimationFrame(animate);
            
            controls.update();
            
            if (highlightMesh.visible) {
                highlightMesh.material.opacity = 0.3 + Math.sin(Date.now() * 0.005) * 0.1;
            }
            
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }
        
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        updateUI();
    </script>
</body>
</html>
